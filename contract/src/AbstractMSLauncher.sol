// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "./interfaces/IBunni.sol";

import "./lib/FullMath.sol";
import "./lib/TickMath.sol";
import "./lib/LiquidityAmounts.sol";
import "./lib/SafeCast.sol";
import "./interfaces/IBalancerVault.sol";
import "./interfaces/IUniswapPairV2.sol";
import "./interfaces/IPoolManager.sol";
import "./types/BalanceDelta.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/Multicall.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

address constant base_operator = 0x4c2217a36821FCBdb85d4eCE8BBCC2Bf5cECBcf2;
address constant base_operator_2 = 0xB9f1a14E1d14C5265447DE1d8A417BeA3BaA5A7e;
address constant base_operator_3 = 0x0C52589a76662ab9fcf6c5FA174d77017b058Ee6;
address constant base_operator_4 = 0x16490C64bFA714B98436F93B1b763020fD801B0B;
address constant base_operator_5 = 0x8856c1E1b30C0CBa94032F8C97c5aFC5cf3B104D;
address constant base_controller = 0xa95661D9693A3f74FBb0F37f9097CA8b22566361;


import "./interfaces/IUniswapV3Pool.sol";
import {IChainlinkAdapter} from "../src/interfaces/IChainlink.sol";
import "../src/lib/TickMath.sol";

enum PoolType {
    UNISWAP_V3,
    PANCAKE_V3,
    AERODROME,
    UNISWAP_V4
}

interface IAerodromePool {
    function slot0() external view returns(
        uint256 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        bool unlocked);

    function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256 amountOut);

    function getReserves() external view returns (uint256 reserve0, uint256 reserve1, uint32 blockTimestampLast);
}

interface IPancakePool {
    function slot0() external view returns(
        uint256 sqrtPriceX96,
        int24 tick,
        uint16 observationIndex,
        uint16 observationCardinality,
        uint16 observationCardinalityNext,
        uint32 feeProtocol,
        bool unlocked);
}

interface IMSPool {
    function swap(
            address syntheticTokenIn,
            address syntheticTokenOut,
            uint256 amountIn
        ) external returns (uint256 amountOut, uint256 fee);

    function quoteSwapOut(
            address syntheticTokenIn,
            address syntheticTokenOut,
            uint256 amountIn
    ) external view returns (uint256 amountOut, uint256 fee);
}

interface IMorpho {
    function flashLoan(address token, uint256 assets, bytes calldata data) external;
}

IMorpho constant morpho = IMorpho(0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb);

struct MSLaunchResult {
    address pool;
    uint256 profit;
}

interface IMSLauncher {
    function getPoolInfoList() external view returns (address[] memory pools, PoolType[] memory poolTypes);
    function getPoolInfo(uint256 poolIndex) external view returns (address pool, PoolType poolType);
    function getPoolCount() external view returns (uint256);

    function getBaseToken() external view returns (address);
    function getQuoteToken() external view returns (address);

    function getChainlinkPrice() external view returns (uint256);
    // function getPoolPrice(uint256 index) external view returns (uint256);

    function getSqrtPriceX96(uint256 index) external view returns (uint256 sqrtPriceX96);
}

abstract contract AbstractMSLauncher is IMSLauncher {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using SafeCast for int256;
    using SafeMath for uint;
    using BalanceDeltaLibrary for BalanceDelta;

    address immutable public    owner;

    address immutable public    pool0;
    address immutable public    pool1;
    address immutable public    pool2;
    address immutable public    pool3;
    address immutable public    pool4;

    PoolType immutable public      poolType0;
    PoolType immutable public      poolType1;
    PoolType immutable public      poolType2;
    PoolType immutable public      poolType3;
    PoolType immutable public      poolType4;
    
    uint256 immutable public    poolCount;

    address immutable public baseToken;
    address immutable public quoteToken;
    
    uint256 immutable public decimalDenominator;
    uint256 immutable public decimalDenominatorSqrt;
    uint256 immutable public decimalNumerator;
    uint256 immutable public decimalNumeratorSqrt;

    address immutable public msBaseToken;
    address immutable public msQuoteToken;

    address immutable public msPool;

    uint256 immutable public startStep;
    uint256 immutable public minStep;

    bool immutable public isMorpho;

    mapping(uint256 => uint256) public lastFailedPrice;

    IPoolManager immutable public v4PoolManager;
    IStateView immutable public v4StateView;
    uint24 immutable public v4Fee;
    int24 immutable public v4TickSpacing;
    address immutable public v4Hooks;
    bytes32 immutable public v4PoolId;


    constructor(
        address _owner, 
        address _baseToken,
        address _msBaseToken,
        address _quoteToken,
        address _msQuoteToken,
        address _msPool,
        uint256 _startStep,
        uint256 _minStep,
        bool _isMorpho)  {
        
        owner = _owner;

        baseToken = _baseToken;
        msBaseToken = _msBaseToken;

        quoteToken = _quoteToken;
        msQuoteToken = _msQuoteToken;

        msPool = _msPool;

        startStep = _startStep;
        minStep = _minStep;

        isMorpho = _isMorpho;
        
        uint8 baseDecimals = IERC20Metadata(_baseToken).decimals();
        uint8 quoteDecimals = IERC20Metadata(_quoteToken).decimals();

        if (baseDecimals > quoteDecimals) {
            decimalNumerator = 1;
            decimalNumeratorSqrt = 1;
            decimalDenominator = 10 ** uint256(baseDecimals - quoteDecimals);
            decimalDenominatorSqrt = 10 ** uint256((baseDecimals - quoteDecimals) / 2);
        } else {
            decimalNumerator = 10 ** uint256(quoteDecimals - baseDecimals);
            decimalNumeratorSqrt = 10 ** uint256((quoteDecimals - baseDecimals) / 2);            
            decimalDenominator = 1;
            decimalDenominatorSqrt = 1;
        }
    }

    function getPoolCount() public view returns (uint256) {
        return poolCount;
    }

    function getBaseToken() public view returns (address) {
        return baseToken;
    }

    function getQuoteToken() public view returns (address) {
        return quoteToken;
    }

    function getStartStep() public view returns (uint256) {
        return startStep;
    }
    
    function getMinStep() public view returns (uint256) {
        return minStep;
    }

    struct TradeParam { 
        uint256 limitPrice;
        uint256 swapAmount;
    }

    function launchWithPricesAndAmounts(
        uint256 poolIndex,
        bool sellBaseToken,
        uint256[] calldata limitPrices,
        uint256[] calldata swapAmounts) external
    {
        uint256 step;
        uint256 poolPrice = getSqrtPriceX96(poolIndex);
        bool priceFlag = sellBaseToken == (baseToken < quoteToken);
        
        for (uint256 i = 0; i < limitPrices.length; i++) {
            if (priceFlag == (poolPrice >= limitPrices[i])) {
                step = swapAmounts[i];
            }
        }

        while (step > minStep && gasleft() > 1000000) {
            try this.launch(poolIndex, step, sellBaseToken, false) returns (int256 _profit) {
                poolPrice = getSqrtPriceX96(poolIndex);
            } catch (bytes memory) {
                step = step >> 1;
            }
        }
    }

    function launch(
        uint256        index,
        uint256        swapAmount,
        bool           sellBaseToken,
        bool           isSimulate
    ) external returns(int256 profit)
    {
        uint256 preBalance = IERC20(baseToken).balanceOf(address(this));
        bytes memory userData = abi.encode(index, sellBaseToken);

        if (isMorpho) {
            morpho.flashLoan(baseToken, swapAmount, userData);
        } else {
            address[] memory assets = new address[](1);
            uint256[] memory amounts = new uint256[](1);

            assets[0] = baseToken;
            amounts[0] = swapAmount;

            IBalancerVault(balancer).flashLoan(address(this), assets, amounts, userData);
        }

        uint256 postBalance = IERC20(baseToken).balanceOf(address(this));
        if (isSimulate && preBalance > postBalance) {
            return int256(postBalance) - int256(preBalance);
        }

        require(postBalance > preBalance, "Profit is 0");
        profit = int256(postBalance) - int256(preBalance);
        IERC20(baseToken).safeTransfer(owner, uint256(profit));
    }

    function onMorphoFlashLoan(uint256 assets, bytes calldata userData) external {
        require(msg.sender == address(morpho));
        (uint256 index, bool sellBaseToken) = abi.decode(userData, (uint256, bool));

        execute(index, assets, sellBaseToken);

        IERC20(baseToken).approve(address(morpho), assets);
    }

    function receiveFlashLoan(
        address[] memory flashLoanTokens,
        uint256[] memory flashloanAmounts,
        uint256[] memory feeAmounts,
        bytes memory     userData
    ) external {
        require(msg.sender == address(balancer));

        (uint256 index, bool sellBaseToken) = abi.decode(userData, (uint256, bool));

        uint256 baseBalance = flashloanAmounts[0];  
        execute(index, baseBalance, sellBaseToken);

        IERC20(flashLoanTokens[0]).safeTransfer(address(balancer), baseBalance);
    }

    function execute(uint256 index, uint256 baseBalance, bool sellBaseToken) internal {
        uint256 quoteBalance = IERC20(quoteToken).balanceOf(address(this));

        if (sellBaseToken) {
            // DEX(Base -> Quote)
            conductSwap(index, true, int256(baseBalance));

            // MS Trade(Quote -> Base)
            conductMSTrade(IERC20(quoteToken).balanceOf(address(this)) - quoteBalance, true);
        } else {
            // MS Trade(Base -> Quote)
            conductMSTrade(baseBalance, false);

            // DEX Quote -> Base
            conductSwap(index, false, int256(IERC20(quoteToken).balanceOf(address(this)) - quoteBalance));
        }
    }

    function conductMSTrade(uint256 inAmount, bool sellBaseToken) internal virtual;

    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) external {
        onSwapV3(amount0, amount1, data);
    }

    function pancakeV3SwapCallback(int256 amount0, int256 amount1, bytes calldata data) external {
        onSwapV3(amount0, amount1, data);
    }

    function onSwapV3(int256 amount0, int256 amount1, bytes calldata data) internal {
        require(amount0 > 0 || amount1 > 0);

        (address tokenIn) = abi.decode(data, (address));
        uint256 amountIn = amount0 > 0 ? uint256(amount0) : uint256(amount1);
        IERC20(tokenIn).safeTransfer(msg.sender, amountIn);
    }

    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        require(msg.sender == address(v4PoolManager));

        (address tokenIn,
        bool zeroForOne,
        int256 amountIn) = abi.decode(data, (address, bool, int256));

        PoolKey memory poolKey = getV4PoolKey();
        BalanceDelta delta = IPoolManager(v4PoolManager).swap(poolKey,
            IPoolManager.SwapParams({
                zeroForOne: zeroForOne,
                amountSpecified: -amountIn,
                sqrtPriceLimitX96: zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1
            }), bytes(""));

        int256 baseAmount = int256(delta.amount0());
        int256 quoteAmount = int256(delta.amount1());

        if (zeroForOne) {
            // Take Quote Token
            v4PoolManager.take(quoteToken, address(this), uint256(quoteAmount));

            // Settle ETH
            IPoolManager(v4PoolManager).sync(address(0));
            IWETH9(baseToken).withdraw(uint256(-baseAmount));
            v4PoolManager.settle{value: uint256(-baseAmount)}();
        } else {
            // Take ETH
            v4PoolManager.take(address(0), address(this), uint256(baseAmount));
            IWETH9(baseToken).deposit{value: uint256(baseAmount)}();

            // Settle Quote Token
            v4PoolManager.sync(quoteToken);
            IERC20(quoteToken).transfer(address(v4PoolManager), uint256(-quoteAmount));
            v4PoolManager.settle();
        }
    }

    function conductSwap(
        uint256 index,
        bool sellBaseToken,
        int256 amount
    ) internal {
        if (amount == 0) {
            return;
        }

        (address pool, PoolType poolType) = getPoolInfo(index);
        bool zeroForOne = baseToken < quoteToken ? sellBaseToken : !sellBaseToken;
        address tokenIn = sellBaseToken ? baseToken : quoteToken;

        if (poolType  == PoolType.UNISWAP_V4) {
            v4PoolManager.unlock(abi.encode(
                address(tokenIn),
                sellBaseToken,
                amount));
        } else {
            IUniswapV3Pool(pool).swap(
                address(this),
                zeroForOne,
                amount,
                zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
                abi.encode(tokenIn));
        }
    }

    function getSqrtPriceX96(uint256 index) public view virtual returns (uint256 sqrtPriceX96) {
        (address pool, PoolType poolType) = getPoolInfo(index);

        if (poolType == PoolType.UNISWAP_V3) {
            (sqrtPriceX96, ,,,,,) = IUniswapV3Pool(pool).slot0();
        } else if (poolType == PoolType.PANCAKE_V3) {
            (sqrtPriceX96, ,,,,,) = IPancakePool(pool).slot0();
        } else if (poolType == PoolType.AERODROME) {
            (sqrtPriceX96, ,,,,) = IAerodromePool(pool).slot0();
        } else if (poolType == PoolType.UNISWAP_V4) {
            (sqrtPriceX96, , ,) = v4StateView.getSlot0(v4PoolId);
        }
    }

    function getPoolInfoList() public view returns (address[] memory pools, PoolType[] memory poolTypes) {
        pools = new address[](poolCount);
        poolTypes = new PoolType[](poolCount);
        for (uint256 i = 0; i < poolCount; i++) {
            (pools[i], poolTypes[i]) = getPoolInfo(i);
        }
    }
    
    function getBaseBalanceList() public view returns (uint256[] memory balances) {
        balances = new uint256[](poolCount);

        for (uint256 i = 0; i < poolCount; i++) {
            (address pool, PoolType poolType) = getPoolInfo(i);
            if (poolType == PoolType.UNISWAP_V4) {
                balances[i] = 0;
            } else {
                balances[i] = IERC20(baseToken).balanceOf(pool);
            }
        }
    }

    function getPoolInfo(uint256 index) public view returns (address pool, PoolType poolType) {
        if (index == 0) {
            pool = pool0;
            poolType = poolType0;
        } else if (index == 1) {
            pool = pool1;
            poolType = poolType1;
        } else if (index == 2) {
            pool = pool2;
            poolType = poolType2;
        } else if (index == 3) {
            pool = pool3;
            poolType = poolType3;
        } else if (index == 4) {
            pool = pool4;
            poolType = poolType4;
        } else {
            revert("Invalid pool index");
        }
    }

    // function getPoolPrice(uint256 index) public view returns (uint256 sqrtPriceX96) {
    //     (address pool, uint8 poolType) = getPoolInfo(index);
    //     sqrtPriceX96 = getSqrtPriceX96(pool, poolType);
    // }
/*
    function getPoolPrice(uint256 pool, uint8 poolType) public view returns (uint256 sqrtPriceX96) {
        if (poolType == 0) {
            (sqrtPriceX96, ,,,,,) = IUniswapV3Pool(pool).slot0();
        } else if (poolType == 1) {
            (sqrtPriceX96, ,,,,,) = IPancakePool(pool).slot0();
        } else if (poolType == 2) {
            (sqrtPriceX96, ,,,,) = IAerodromePool(pool).slot0();
        } else if (poolType == 3) {
            (sqrtPriceX96, ,,,,,) = v4StateView.slot0(v4PoolId);
        }

        if (baseToken > quoteToken) {
            sqrtPriceX96 = (1 << 192) / sqrtPriceX96;
        }
    }
    */

    function sqrt(uint256 x) internal pure returns (uint256 result) {
        if (x == 0) return 0;

        // Initial guess: bitwise log2 approximation
        uint256 z = 1;
        uint256 y = x;
        if (y >= 0x100000000000000000000000000000000) { y >>= 128; z <<= 64; }
        if (y >= 0x10000000000000000) { y >>= 64; z <<= 32; }
        if (y >= 0x100000000) { y >>= 32; z <<= 16; }
        if (y >= 0x10000) { y >>= 16; z <<= 8; }
        if (y >= 0x100) { y >>= 8; z <<= 4; }
        if (y >= 0x10) { y >>= 4; z <<= 2; }
        if (y >= 0x8) { z <<= 1; }

        // 7 Babylonian iterations (sufficient for convergence)
        for (uint8 i = 0; i < 7; i++) {
            z = (z + x / z) >> 1;
        }

        // Final correction (in case of overestimate)
        result = x / z;
        return (z + result) >> 1;
    }


    function getV4PoolKey() internal view returns (PoolKey memory poolKey) {
        poolKey = PoolKey({
            token0: address(0),
            token1: quoteToken,
            fee: v4Fee,
            tickSpacing: v4TickSpacing,
            hooks: v4Hooks
        });
    }     

    function getV4PoolId() internal view returns (bytes32 poolId) {
        PoolKey memory poolKey = getV4PoolKey();
        assembly ("memory-safe") {  
            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)
            poolId := keccak256(poolKey, 0xa0)
        }
    }

    // function simulateMSTrade(
    //     bool sellBaseToken,
    //     uint256 inAmount
    // ) external returns (uint256 outAmount) {
    //     if (sellBaseToken) {
    //         // Quote -> Base
    //         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));
    //         conductMSTrade(inAmount, sellBaseToken);
    //         outAmount = IERC20(baseToken).balanceOf(address(this)) - baseBalance;
    //     }
    //     else
    //     {
    //         // Base -> Quote
    //         uint256 quoteBalance = IERC20(quoteToken).balanceOf(address(this));
    //         conductMSTrade(inAmount, sellBaseToken);
    //         outAmount = IERC20(quoteToken).balanceOf(address(this)) - quoteBalance;
    //     }
    // }

    function simulatePriceAndAmount(
        AbstractMSLauncher launcher,
        uint256 index,
        bool sellBaseToken,
        int256 delta
    ) external returns (uint256 sqrtPriceX96, uint256 swapAmount) {
        // start swap
        conductSwap(
            index,
            ((delta > 0) != sellBaseToken),
            sellBaseToken ? (-delta) : delta);
        sqrtPriceX96 = getSqrtPriceX96(index);

        uint256 step = startStep;
        uint256 halvingCount;

        while (step >= 1e15) {
            try launcher.launch(index, step, sellBaseToken, false) returns (int256 _profit) {
                swapAmount = swapAmount + step;
            } catch {
                step = step / 2;
                halvingCount++;

                if (gasleft() < 1000000 || halvingCount > 10) {
                    break;
                }
            }
        }
    }

    function simulateTrade(
        AbstractMSLauncher launcher,
        uint256 index,
        bool sellBaseToken,
        int256 delta,
        uint256 swapAmount
    ) external returns (uint256 sqrtPriceX96, int256 profit, uint256 gasUsed) {
        // start swap
        conductSwap(
            index,
            ((delta > 0) != sellBaseToken),
            sellBaseToken ? (-delta) : delta);

        sqrtPriceX96 = getSqrtPriceX96(index);
        
        // launch
        uint256 gas = gasleft();
        try launcher.launch(index, swapAmount, sellBaseToken, false) returns (int256 _profit) {
            profit =  _profit;
        } catch {
        }
        gasUsed = gas - gasleft();
    }

    function simulateLaunch(
        AbstractMSLauncher launcher,
        uint256 index,
        bool sellBaseToken,
        int256 delta,
        uint256[] memory limitPrices,
        uint256[] memory swapAmounts
    ) external returns (int256 profit, uint256 gasUsed) {

        // start swap
        conductSwap(
            index,
        ((delta > 0) != sellBaseToken),
        sellBaseToken ? (-delta) : delta);

        // launch
        uint256 prevBalance = IERC20(baseToken).balanceOf(owner);

        uint256 gas = gasleft();
        launcher.launchWithPricesAndAmounts(index, sellBaseToken, limitPrices, swapAmounts);
        gasUsed = gas - gasleft();
        
        uint256 postBalance = IERC20(baseToken).balanceOf(owner);
        profit = int256(postBalance) - int256(prevBalance);
    }
/*
    struct PoolParam {
        uint256[] calldata limitPrices;
        uint256[] calldata swapAmounts;
    }

    function launchWithParam(
        PoolParam[] calldata poolParams,
        bool sellBaseToken
    ) external returns (int256 profit, uint256 gasUsed) {

        uint256 poolCount = poolParams.length;
        uint256[] memory swapAmounts = new uint256[](poolCount);
        uint256[] memory limitPrices = new uint256[](poolCount);
        uint256 totalDelta;

        for (uint256 i = 0; i < poolCount; i++) {
            uint256 sqrtPriceX96 = getSqrtPriceX96(i);

            for (uint256 j = 0; j < poolParams[i].limitPrices.length; j++) {
                uint256 limitPrice = poolParams[i].limitPrices[j];
                if (sellBaseToken == (limitPrice < sqrtPriceX96)) {
                    uint256 delta = (limitPrice < sqrtPriceX96 ? limitPrice - sqrtPriceX96 : sqrtPriceX96 - limitPrice);
                    
                    swapAmounts[i] = poolParams[i].swapAmounts[j];
                    delta[i] = delta;
                    totalDelta = totalDelta + delta;
                    break;
                }
            }
        }
    }
*/
    function getLimitPrice(
        AbstractMSLauncher launcher,
        uint256 index,
        bool sellBaseToken,
        int256 start,
        uint256 step,
        uint256 stepCount,
        uint256 swapAmount,
        uint256 minProfit
    ) external returns (uint256 limtSqrtPriceX96, uint256 chainlinkPrice, int256 deltaAmount, int256 profit)
    {
        deltaAmount = start;

        // start swap
        conductSwap(
            index,
            ((start > 0) != sellBaseToken),
            sellBaseToken ? (-start) : start);

        for (uint256 i = 0; i < stepCount; i++) {
            uint256 sqrtPriceX96 = getSqrtPriceX96(index);
            
            try launcher.launch(index, swapAmount, sellBaseToken, true) returns (int256 _profit) {
                if (_profit < int256(minProfit)) {
                    continue;
                }

                limtSqrtPriceX96 = sqrtPriceX96;
                profit = _profit;
                break;
            } catch {
                deltaAmount = deltaAmount + int256(step);

                // Step swap    
                conductSwap(
                    index,
                    !sellBaseToken,
                    sellBaseToken ? (-int256(step)) : int256(step));
            }
        }

        chainlinkPrice = launcher.getChainlinkPrice();
    }

    function convertSqrtPriceX96ToChainlink(uint256 sqrtPriceX96) public view returns (uint256 chainlinkPrice) {
        if (sqrtPriceX96 == 0) {
            return 0;
        }

        if (baseToken < quoteToken) {
            return (((sqrtPriceX96 * sqrtPriceX96 * 1e4 * decimalDenominatorSqrt / decimalNumeratorSqrt) >> 96) * 1e4 * decimalDenominatorSqrt / decimalNumeratorSqrt) >> 96;
        } else {
            return 1e40 / ((((sqrtPriceX96 * sqrtPriceX96 * 1e4 * decimalDenominatorSqrt / decimalNumeratorSqrt) >> 96) * 1e4 * decimalDenominatorSqrt / decimalNumeratorSqrt) >> 96);
        }
    }
}