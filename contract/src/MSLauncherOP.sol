// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "./AbstractMSLauncher.sol";

import "./lib/FullMath.sol";
import "./lib/TickMath.sol";
import "./lib/SafeCast.sol";
import "./interfaces/IUniswapPairV2.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/Multicall.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/IUniswapV3Pool.sol";
import {IChainlinkAdapter} from "../src/interfaces/IChainlink.sol";
import "../src/lib/TickMath.sol";

address constant msETH_OP = 0x1610e3c85dd44Af31eD7f33a63642012Dca0C5A5;
address constant WETH_OP = 0x4200000000000000000000000000000000000006;
address constant WETH_msETH_PAIR_OP = 0x917AA69D539D6518440dd0BEA2eaAc142a8d5610;

address constant msOP_OP = 0x33bCa143d9b41322479E8d26072a00a352404721;
address constant OP_OP = 0x4200000000000000000000000000000000000042;
address constant msOP_OP_PAIR_OP = 0xF6fFB55bFb4f149B725211E7eF1CC9F3A67c5b01;

address constant msUSD_OP = 0x9dAbAE7274D28A45F0B65Bf8ED201A5731492ca0;
address constant USDC_OP = 0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85;
address constant msUSD_USDC_PAIR_OP = 0xe07388b2a7bb29d3Ad8989e1074Bd00Bd0d3C43d;
address constant USDC_E_OP = 0x7F5c764cBc14f9669B88837ca1490cCa17c31607;
address constant msUSD_USDC_E_PAIR_OP = 0xe148D6Ae042De77c1f9fe0d6c495EbfD7b705B4c;

address constant msPool_OP = 0x6394152946dc3E0bABAA474eE9d366ef31f959c0;

address constant ETH_FEED_OP = 0x13e3Ee699D1909E989722E753853AE30b17e08c5;
address constant OP_FEED_OP = 0x0D276FC14719f9292D5C1eA2198673d1f4269246;

abstract contract MSLauncherOP is AbstractMSLauncher {

    address immutable msBaseTokenPair;
    address immutable msQuoteTokenPair;
    
    constructor(
        address _owner, 
        address _baseToken,
        address _msBaseToken,
        address _msBaseTokenPair,
        address _quoteToken,
        address _msQuoteToken,
        address _msQuoteTokenPair,
        address _msPool,
        uint256 _startStep,
        uint256 _minStep) 
        AbstractMSLauncher(
            _owner,
            _baseToken,
            _msBaseToken,
            _quoteToken,    
            _msQuoteToken,
            _msPool,
            _startStep,
            _minStep,
            false) 
    {
        msBaseTokenPair = _msBaseTokenPair;
        msQuoteTokenPair = _msQuoteTokenPair;
    }

    // fallback() external {
    //     launchInternal(startStep, minStep, false);
    // }    
    // function simulate() external returns (int256 profit, uint256 gasUsed) {
    //     uint256 gas = gasleft();

    //     uint256 preBalance = IERC20(baseToken).balanceOf(address(this));
    //     uint256 preBalanceOwner = IERC20(baseToken).balanceOf(owner);

    //     launchInternal(startStep, minStep, true);

    //     uint256 postBalance = IERC20(baseToken).balanceOf(address(this));
    //     uint256 postBalanceOwner = IERC20(baseToken).balanceOf(owner);

    //     if (postBalanceOwner > preBalanceOwner) {
    //         profit = int256(postBalanceOwner) - int256(preBalanceOwner);
    //     } else {
    //         profit = int256(postBalance) - int256(preBalance);
    //     }
        
    //     gasUsed = gas - gasleft();
    // }
    
    function conductMSTrade(uint256 inAmount, bool sellBaseToken) internal override {
        if (sellBaseToken)
        {
            // Quote -> msQuote
            _swapV2(msQuoteTokenPair, quoteToken, inAmount);

            // msQuote -> msBase
            (uint256 msBaseAmount, ) = IMSPool(msPool).swap(
                msQuoteToken,
                msBaseToken,
                IERC20(msQuoteToken).balanceOf(address(this)));
            
            // msBase -> Base
            _swapV2(msBaseTokenPair, msBaseToken, msBaseAmount);
        }
        else
        {
            // Base -> msBase
            _swapV2(msBaseTokenPair, baseToken, inAmount);

            // msBase -> msQuote
            (uint256 msQuoteTokenAmount, ) = IMSPool(msPool).swap(
                msBaseToken,
                msQuoteToken,
                IERC20(msBaseToken).balanceOf(address(this)));
            
            // msQuote -> Quote
            _swapV2(msQuoteTokenPair, msQuoteToken, IERC20(msQuoteToken).balanceOf(address(this)));
        }
    }

    function _swapV2(address pool, address tokenIn, uint256 amountIn) internal {
        bool zeroForOne = tokenIn == IUniswapPairV2(pool).token0();
        uint256 amountOut = IAerodromePool(pool).getAmountOut(amountIn, tokenIn);
        
        IUniswapPairV2(pool).swap(
            zeroForOne ? 0 : amountOut,
            zeroForOne ? amountOut : 0,
            address(this),
            abi.encode(tokenIn, amountIn));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        onSwapV2(sender, amount0, amount1, data);
    }

    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external {
        onSwapV2(sender, amount0, amount1, data);
    }

    function onSwapV2(address sender, uint amount0, uint amount1, bytes calldata data) internal {
        require(msg.sender == msBaseTokenPair|| msg.sender == msQuoteTokenPair, "NOAUTH");

        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        IERC20(tokenIn).transfer(msg.sender, amountIn);
    }
}


contract MSLauncherOP_WETH_USDC is MSLauncherOP {
    constructor(address _owner) 
        MSLauncherOP(
            _owner,
            WETH_OP,
            msETH_OP,
            WETH_msETH_PAIR_OP,
            USDC_OP,
            msUSD_OP,
            msUSD_USDC_PAIR_OP,
            msPool_OP,
            0.2 ether,
            0.05 ether)
    {
        poolCount = 3;

        pool0 = 0x478946BcD4a5a22b316470F5486fAfb928C0bA25;
        poolType0 = PoolType.AERODROME;

        pool1 = 0x1fb3cf6e48F1E7B10213E7b6d87D4c073C7Fdb7b;
        poolType1 = PoolType.UNISWAP_V3;

        pool2 = 0xc1738D90E2E26C35784A0d3E3d8A9f795074bcA4;
        poolType2 = PoolType.UNISWAP_V3;
    }

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(ETH_FEED_OP).latestAnswer());
    }
}


contract MSLauncherOP_WETH_USDC_E is MSLauncherOP {
    constructor(address _owner) 
        MSLauncherOP(
            _owner,
            WETH_OP,
            msETH_OP,
            WETH_msETH_PAIR_OP,
            USDC_E_OP,
            msUSD_OP,
            msUSD_USDC_E_PAIR_OP,
            msPool_OP,
            0.2 ether,
            0.05 ether)
    {
        poolCount = 1;

        pool0 = 0x85149247691df622eaF1a8Bd0CaFd40BC45154a9;
        poolType0 = PoolType.UNISWAP_V3;
    }

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(ETH_FEED_OP).latestAnswer());
    }
}


contract MSLauncherOP_WETH_OP is MSLauncherOP {

    constructor(address _owner) 
        MSLauncherOP(
            _owner,
            WETH_OP,
            msETH_OP,
            WETH_msETH_PAIR_OP,
            OP_OP,
            msOP_OP,
            msOP_OP_PAIR_OP,
            msPool_OP,
            0.2 ether,
            0.05 ether)
    {
        poolCount = 4;

        pool0 = 0x68F5C0A2DE713a54991E01858Fd27a3832401849;
        poolType0 = PoolType.UNISWAP_V3;

        pool1 = 0x4DC22588Ade05C40338a9D95A6da9dCeE68Bcd60;
        poolType1 = PoolType.AERODROME;

        pool2 = 0xFC1f3296458F9b2a27a0B91dd7681C4020E09D05;
        poolType2 = PoolType.UNISWAP_V3;

        pool3 = 0x84a67CD00EB244edCa2288346ADD251A783243c8;
        poolType3 = PoolType.AERODROME;
   }

    function getChainlinkPrice() public override view returns (uint256) {
        return 
            uint256(IChainlinkAdapter(ETH_FEED_OP).latestAnswer()) * 1e8 /
            uint256(IChainlinkAdapter(OP_FEED_OP).latestAnswer());
    }
}


contract MSLauncherOP_OP_USDC is MSLauncherOP {
    constructor(address _owner) 
        MSLauncherOP(
            _owner,
            OP_OP,
            msOP_OP,
            msOP_OP_PAIR_OP,
            USDC_OP,
            msUSD_OP,
            msUSD_USDC_PAIR_OP,
            msPool_OP,
            800 ether,
            56 ether)
    {
        poolCount = 2;

        pool0 = 0xB533c12fB4e7b53b5524EAb9b47d93fF6C7A456F;
        poolType0 = PoolType.UNISWAP_V3;

        pool1 = 0xeBD5311beA1948e1441333976EadCFE5fBda777C;
        poolType1 = PoolType.AERODROME;
    }

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(OP_FEED_OP).latestAnswer());
    }
}


contract MSLauncherOP_OP_USDC_E is MSLauncherOP {
    constructor(address _owner) 
        MSLauncherOP(
            _owner,
            OP_OP,
            msOP_OP,
            msOP_OP_PAIR_OP,
            USDC_E_OP,
            msUSD_OP,
            msUSD_USDC_E_PAIR_OP,
            msPool_OP,
            800 ether,
            56 ether)
    {
        poolCount = 2;

        pool0 = 0x0df083de449F75691fc5A36477a6f3284C269108;
        poolType0 = PoolType.UNISWAP_V3;
    }

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(OP_FEED_OP).latestAnswer());
    }
}