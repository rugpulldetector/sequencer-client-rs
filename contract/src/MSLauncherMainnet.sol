// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "./AbstractMSLauncher.sol";
import "./interfaces/ICurvePool.sol";

import "./lib/FullMath.sol";
import "./lib/TickMath.sol";
import "./lib/SafeCast.sol";
import "./interfaces/IUniswapPairV2.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/Multicall.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/IUniswapV3Pool.sol";
import {IChainlinkAdapter} from "../src/interfaces/IChainlink.sol";
import "../src/lib/TickMath.sol";

address constant msETH = 0x64351fC9810aDAd17A690E4e1717Df5e7e085160;
address constant WETH_msETH_CURVE = 0xa4c567c662349BeC3D0fB94C4e7f85bA95E208e4;

address constant msUSD = 0xab5eB14c09D416F0aC63661E57EDB7AEcDb9BEfA;
address constant msUSD_crvFRAX_CURVE = 0xc3b19502F8c02be75F3f77fd673503520DEB51dD;

address constant MSPOOL = 0x3364f53cB866762Aef66DeEF2a6b1a17C1F17f46;

address constant ETH_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;


contract MSLauncherMainnet is AbstractMSLauncher {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using SafeCast for int256;
    using SafeMath for uint;
 
    constructor(address _owner) 
        AbstractMSLauncher(
            _owner,
            WETH,
            msETH,
            USDC,
            msUSD,
            MSPOOL,
            2 ether,
            1 ether,
            true)
    {
        poolCount = 3;

        pool0 = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
        poolType0 = PoolType.UNISWAP_V3;

        pool1 = 0xE0554a476A092703abdB3Ef35c80e0D76d32939F;
        poolType1 = PoolType.UNISWAP_V3;

        pool2 = address(0x01);
        poolType2 = PoolType.UNISWAP_V4;
        v4PoolManager = IPoolManager(0x000000000004444c5dc75cB358380D2e3dE08A90);
        v4StateView = IStateView(0x7fFE42C4a5DEeA5b0feC41C94C136Cf115597227);

        v4Fee = 500;
        v4TickSpacing = 10;
        v4Hooks = address(0);
        v4PoolId = getV4PoolId();

        IERC20(WETH).approve(WETH_msETH_CURVE, type(uint256).max);
        IERC20(msETH).approve(WETH_msETH_CURVE, type(uint256).max);
        IERC20(msUSD).approve(msUSD_crvFRAX_CURVE, type(uint256).max);
        IERC20(USDC).approve(msUSD_crvFRAX_CURVE, type(uint256).max);
    }   

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(ETH_FEED).latestAnswer());
    }

    function conductMSTrade(uint256 inAmount, bool sellBaseToken) internal override {
        if (sellBaseToken)
        {
            // USDC -> msUSD
            ICurvePool(msUSD_crvFRAX_CURVE).exchange_underlying(2, 0, inAmount, 0);

            // msUSD -> msETH
            (uint256 msETHAmount, ) = IMSPool(msPool).swap(
                msUSD,
                msETH,
                IERC20(msUSD).balanceOf(address(this)));
            
            // msETH -> WETH
            ICurvePool(WETH_msETH_CURVE).exchange(0, 1, msETHAmount, 0);
        }
        else
        {
            // WETH -> msETH
            ICurvePool(WETH_msETH_CURVE).exchange(1, 0, inAmount, 0);

            // msETH -> msUSD
            (uint256 msUSDAmount, ) = IMSPool(msPool).swap(
                msETH,
                msUSD,
                IERC20(msETH).balanceOf(address(this)));
            
            // msUSD -> USDC
            ICurvePool(msUSD_crvFRAX_CURVE).exchange_underlying(0, 2, msUSDAmount, 0);         
        }
    }    

    function getSqrtPriceX96(uint256 index) public view override returns (uint256 sqrtPriceX96) {
        (address pool, PoolType poolType) = getPoolInfo(index);

        if (poolType == PoolType.UNISWAP_V3) {
            (sqrtPriceX96, ,,,,,) = IUniswapV3Pool(pool).slot0();
        } else if (poolType == PoolType.PANCAKE_V3) {
            (sqrtPriceX96, ,,,,,) = IPancakePool(pool).slot0();
        } else if (poolType == PoolType.AERODROME) {
            (sqrtPriceX96, ,,,,) = IAerodromePool(pool).slot0();
        } else if (poolType == PoolType.UNISWAP_V4) {
            (sqrtPriceX96, , ,) = v4StateView.getSlot0(v4PoolId);
            sqrtPriceX96 = (1 << 192) / sqrtPriceX96;
        }
    }

    fallback() payable external {
    }
}

contract MSLauncherRouterMainnnet {
    address immutable public owner;
    MSLauncherMainnet immutable public launcher;

    constructor(address _owner) {
        owner = _owner;
        launcher = new MSLauncherMainnet(address(this));
    }

    function getLauncher() external view returns (MSLauncherMainnet) {
        return launcher;
    }

    fallback() payable external {
    }

    function launch(uint256[] memory bidPrices, uint256[] memory askPrices) payable external {
        uint256 gas = gasleft();
        uint256 poolCount = launcher.poolCount();
        uint256 startStep = launcher.startStep();
        uint256 minStep = launcher.minStep();

        uint256[] memory prices = new uint256[](poolCount);
        uint256 step = startStep;

        for (uint256 i = 0; i < poolCount; i++) {
            prices[i] = launcher.getSqrtPriceX96(i);
        }


        while (gasleft() > 1000000) {
            uint256 selectedIndex =  type(uint256).max;
            uint256 selectedPrice = 0;

            bool sellBaseToken = false;
            uint256 maxDelta = 0;

            for (uint256 i = 0; i < poolCount; i++) {
                uint256 price = prices[i];
                uint256 bidPrice = bidPrices[i];
                uint256 askPrice = askPrices[i];
                
                if (price <= bidPrice) {
                    uint256 delta = bidPrice - price;
                    if (delta >= maxDelta) {
                        maxDelta = delta;
                        sellBaseToken = true;
                        selectedIndex = i;
                        selectedPrice = bidPrice;
                    }
                }

                if (price >= askPrice) {
                    uint256 delta = price - askPrice;
                    if (delta >= maxDelta) {
                        maxDelta = delta;
                        sellBaseToken = false;
                        selectedIndex = i;
                        selectedPrice = askPrice;
                    }
                }
            }

            if (selectedIndex == type(uint256).max) {
                break;
            }

            try launcher.launch(selectedIndex, step, sellBaseToken, false) returns (int256 _profit) {
                prices[selectedIndex] = launcher.getSqrtPriceX96(selectedIndex);
            } catch (bytes memory) {
                step = step >> 1;
                if (step < minStep) {
                    break;
                }
            }
        }

        uint256 profit = IERC20(WETH).balanceOf(address(this));
        uint256 cost = (gas - gasleft()) * tx.gasprice;

        require(profit >= cost, "Profit is less than cost");

        IWETH9(WETH).withdraw(profit);

        if (msg.value > 0) {
            uint256 bribe = (profit - cost) * msg.value / 100;
            block.coinbase.transfer(bribe);
        }

        payable(owner).transfer(address(this).balance);
    }
}

/*
contract MSSimulatorMainnet is MSLauncherMainnet {

    constructor() MSLauncherMainnet(address(this)) {}

    function getLimitPrice(
        MSLauncherMainnet launcher,
        uint256 index,
        bool sellBaseToken,
        int256 start,
        uint256 step,
        uint256 stepCount,
        uint256 swapAmount,
        uint256 minProfit
    ) external
        returns (uint256 limtSqrtPriceX96, uint256 chainlinkPrice, int256 deltaAmount, uint256 profit)
    {
        (address pool, PoolType poolType) = launcher.getPoolInfo(index);
        address baseToken = launcher.getBaseToken();
        address quoteToken = launcher.getQuoteToken();
        
        deltaAmount = start;

        // start swap
        conductSwap(
            index,
            ((start > 0) != sellBaseToken),
            sellBaseToken ? (-start) : start);

        for (uint256 i = 0; i < stepCount; i++) {
            uint256 sqrtPriceX96 = launcher.getSqrtPriceX96(index);
            
            try launcher.launch(index, swapAmount, sellBaseToken, true) returns (int256 _profit) {
                if (_profit < int256(minProfit)) {
                    continue;
                }

                limtSqrtPriceX96 = sqrtPriceX96;
                profit = uint256(_profit);
                break;
            } catch {
                deltaAmount = deltaAmount + int256(step);

                // step swap    
                conductSwap(
                    index,
                    !sellBaseToken,
                    sellBaseToken ? (-int256(step)) : int256(step));
           }
        }

        chainlinkPrice = launcher.getChainlinkPrice();
    }  
}*/