// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "./AbstractMSLauncher.sol";

import "./lib/FullMath.sol";
import "./lib/TickMath.sol";
import "./lib/SafeCast.sol";
import "./interfaces/IUniswapPairV2.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/utils/Multicall.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "./interfaces/IUniswapV3Pool.sol";
import {IChainlinkAdapter} from "../src/interfaces/IChainlink.sol";
import "../src/lib/TickMath.sol";

address constant WETH_BASE = 0x4200000000000000000000000000000000000006;
address constant msETH_BASE = 0x7Ba6F01772924a82D9626c126347A28299E98c98;
address constant WETH_msETH_PAIR_BASE = 0xDE4FB30cCC2f1210FcE2c8aD66410C586C8D1f9A;

address constant USDC_BASE = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;
address constant msUSD_BASE = 0x526728DBc96689597F85ae4cd716d4f7fCcBAE9d;
address constant msUSD_USDC_PAIR_BASE = 0xcEFC8B799a8EE5D9b312aeca73262645D664AaF7;
address constant msUSD_USDC_PAIR_BASE_2 = 0x7501bc8Bb51616F79bfA524E464fb7B41f0B10fB;

address constant msPool_BASE = 0xc614136d6c5AB85bc2aCF0ec2652351642d7F54E;

address constant ETH_FEED_BASE = 0x71041dddad3595F9CEd3DcCFBe3D1F4b0a16Bb70;


contract MSLauncherBase is AbstractMSLauncher {
    using SafeERC20 for IERC20;
    using SafeCast for uint256;
    using SafeCast for int256;
    using SafeMath for uint;
 
    constructor(address _owner) 
        AbstractMSLauncher(
            _owner,
            WETH_BASE,
            msETH_BASE,
            USDC_BASE,
            msUSD_BASE,
            msPool_BASE,
            3 ether,
            1.5 ether,
            true)
    {
        poolCount = 3;

        pool0 = 0xb2cc224c1c9feE385f8ad6a55b4d94E92359DC59;
        poolType0 = PoolType.AERODROME;

        pool1 = 0xd0b53D9277642d899DF5C87A3966A349A798F224;
        poolType1 = PoolType.UNISWAP_V3;

        // pool2 = 0xB775272E537cc670C65DC852908aD47015244EaF;
        // poolType2 = PoolType.PANCAKE_V3;

        pool2 = 0x72AB388E2E2F6FaceF59E3C3FA2C4E29011c2D38;
        poolType2 = PoolType.PANCAKE_V3;

        // pool4 = address(0x01);
        // poolType4 = PoolType.UNISWAP_V4;
        // v4PoolManager = IPoolManager(0x498581fF718922c3f8e6A244956aF099B2652b2b);
        // v4StateView = IStateView(0xA3c0c9b65baD0b08107Aa264b0f3dB444b867A71);
        // v4PoolId = 0x96d4b53a38337a5733179751781178a2613306063c511b78cd02684739288c0a;
        // v4Fee = 500;
        // v4TickSpacing = 10;
        // v4Hooks = address(0);
    }

    function getChainlinkPrice() public override view returns (uint256) {
        return uint256(IChainlinkAdapter(ETH_FEED_BASE).latestAnswer());
    }

    function conductMSTrade(uint256 inAmount, bool sellBaseToken) internal override {
        uint256 amountOut = IAerodromePool(msUSD_USDC_PAIR_BASE).getAmountOut(1e21, msUSD_BASE);
        uint256 mUSDPrice = amountOut * 1000 / 9995;

        (uint256 sqrtPriceX96, int24 tick, , , , ) = IAerodromePool(msUSD_USDC_PAIR_BASE_2).slot0();
        uint256 mUSDPrice2 = convertSqrtPriceX96ToChainlink(sqrtPriceX96);

        if (sellBaseToken)
        {
            // USDC -> msUSD
            if (mUSDPrice > mUSDPrice2)
            {
                IUniswapV3Pool(msUSD_USDC_PAIR_BASE_2).swap(
                    address(this),
                    false,
                    inAmount.toInt256(),
                    TickMath.MAX_SQRT_RATIO - 1,
                    abi.encode(USDC_BASE));
            }
            else
            {
                _swapV2(msUSD_USDC_PAIR_BASE, USDC_BASE, inAmount);            
            }

            // msUSD -> msETH
            (uint256 msETHAmount, ) = IMSPool(msPool_BASE).swap(
                msUSD_BASE,
                msETH_BASE,
                IERC20(msUSD_BASE).balanceOf(address(this)));
            
            // msETH -> WETH
            _swapV2(WETH_msETH_PAIR_BASE, msETH_BASE, msETHAmount);
        }
        else
        {
            // WETH -> msETH
            _swapV2(WETH_msETH_PAIR_BASE, WETH_BASE, inAmount);

            // msETH -> msUSD
            (uint256 msUSDAmount, ) = IMSPool(msPool_BASE).swap(
                msETH_BASE,
                msUSD_BASE,
                IERC20(msETH_BASE).balanceOf(address(this)));
            

            // msUSD -> USDC
            if (mUSDPrice < mUSDPrice2)
            {
                IUniswapV3Pool(msUSD_USDC_PAIR_BASE_2).swap(
                    address(this),
                    true,
                    msUSDAmount.toInt256(),
                    TickMath.MIN_SQRT_RATIO + 1,
                    abi.encode(msUSD_BASE));
            }
            else
            {
                _swapV2(msUSD_USDC_PAIR_BASE, msUSD_BASE, IERC20(msUSD_BASE).balanceOf(address(this)));
            }
        }
    }

    function _swapV2(address pool, address tokenIn, uint256 amountIn) internal {
        bool zeroForOne = tokenIn == IUniswapPairV2(pool).token0();
        uint256 amountOut = IAerodromePool(pool).getAmountOut(amountIn, tokenIn);
        
        IUniswapPairV2(pool).swap(
            zeroForOne ? 0 : amountOut,
            zeroForOne ? amountOut : 0,
            address(this),
            abi.encode(tokenIn, amountIn));
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        onSwapV2(sender, amount0, amount1, data);
    }

    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external {
        onSwapV2(sender, amount0, amount1, data);
    }

    function onSwapV2(address sender, uint amount0, uint amount1, bytes calldata data) internal {
        require(msg.sender == msUSD_USDC_PAIR_BASE || msg.sender == WETH_msETH_PAIR_BASE, "NOAUTH");

        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));
        IERC20(tokenIn).safeTransfer(msg.sender, amountIn);
    }  

    fallback() payable external {
        if (msg.data.length == 0) {
            return;
        }

        uint256[] memory prices = new uint256[](poolCount);
        uint256[] memory bidPrices = new uint256[](poolCount);
        uint256[] memory askPrices = new uint256[](poolCount);
        uint256 step = startStep;
        // (uint96[] memory bidPrices, uint96[] memory askPrices) = abi.decode(msg.data, (uint96[], uint96[]));

        for (uint256 i = 0; i < poolCount; i++) {
            bidPrices[i] = uint256(uint96(bytes12(msg.data[i * 24:i * 24 + 12])));
            askPrices[i] = uint256(uint96(bytes12(msg.data[i * 24 + 12:i * 24 + 24])));
            prices[i] = getSqrtPriceX96(i);
        }


        while (gasleft() > 1000000) {
            uint256 selectedIndex =  type(uint256).max;
            uint256 selectedPrice = 0;

            bool sellBaseToken = false;
            uint256 maxDelta = 0;
            // uint256 maxBidPrice = 0;
            // uint256 minAskPrice = type(uint256).max;

            // selectedIndex = 3;
            // sellBaseToken = false;

            for (uint256 i = 0; i < poolCount; i++) {
                uint256 price = prices[i];
                uint256 bidPrice = bidPrices[i];
                uint256 askPrice = askPrices[i];
                
                if (price >= bidPrice) {
                    // if (maxBidPrice < price) {
                    //     maxBidPrice = price;
                    //     selectedIndex = i;
                    //     sellBaseToken = true;
                    // }
                    uint256 delta = price - bidPrice;
                    if (delta >= maxDelta) {
                        maxDelta = delta;
                        sellBaseToken = true;
                        selectedIndex = i;
                        selectedPrice = bidPrice;
                    }
                }

                if (price <= askPrice) {
                    // if (minAskPrice > price) {
                    //     minAskPrice = price;
                    //     selectedIndex = i;
                    //     sellBaseToken = false;
                    // }
                    uint256 delta = askPrice - price;
                    if (delta >= maxDelta) {
                        maxDelta = delta;
                        sellBaseToken = false;
                        selectedIndex = i;
                        selectedPrice = askPrice;
                    }
                }
            }

            if (selectedIndex == type(uint256).max) {
                break;
            }

            if (selectedPrice == lastFailedPrice[selectedIndex]) {
                break;
            }

            try this.launch(selectedIndex, step, sellBaseToken, false) returns (int256 _profit) {
                prices[selectedIndex] = getSqrtPriceX96(selectedIndex);
            } catch (bytes memory) {
                step = step >> 1;
                if (step < minStep) {
                    lastFailedPrice[selectedIndex] = selectedPrice;
                    break;
                }
            }
        }
    }
}

/*

contract MSSimulatorBase is MSLauncherBase {

    constructor() MSLauncherBase(address(this)) {}   

    function simuate(
        MSLauncherBase launcher,
        uint256 index,
        bool sellBaseToken,
        int256 start,
        uint256 swapAmount
    ) external returns (uint256 sqrtPriceX96, int256 profit, uint256 gasUsed) {
        (address pool, PoolType poolType) = launcher.getPoolInfo(index);
        address baseToken = launcher.getBaseToken();
        address quoteToken = launcher.getQuoteToken();

        // start swap
        _conductSwap(
            address(this),
            pool,
            poolType,
            baseToken,
            quoteToken,
            ((start > 0) != sellBaseToken),
            sellBaseToken ? (-start) : start);

        sqrtPriceX96 = launcher.getSqrtPriceX96(index);
        uint256 gas = gasleft();
        try launcher.launch(index, swapAmount, sellBaseToken, true) returns (int256 _profit) {
            profit = _profit;
        } catch {
        }
        gasUsed = gas - gasleft();
    }

    function getLimitPrice(
        MSLauncherBase launcher,
        uint256 index,
        bool sellBaseToken,
        int256 start,
        uint256 step,
        uint256 stepCount,
        uint256 swapAmount,
        uint256 minProfit
    ) external returns (uint256 limtSqrtPriceX96, uint256 chainlinkPrice, int256 deltaAmount, int256 profit)
    {
        (address pool, PoolType poolType) = launcher.getPoolInfo(index);

        address baseToken = launcher.getBaseToken();
        address quoteToken = launcher.getQuoteToken();
        
        deltaAmount = start;

        // start swap
        _conductSwap(
            address(this),
            pool,
            poolType,
            baseToken,
            quoteToken,
            ((start > 0) != sellBaseToken),
            sellBaseToken ? (-start) : start);


        // Step swap
        // if (poolType == PoolType.UNISWAP_V3) {

            // if (start > 0) {
            //     if (sellBaseToken) {
            //         IUniswapV3Pool(pool).swap(
            //             address(this),
            //             !zeroForOne,
            //             -int256(start),
            //             !zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
            //             abi.encode(quoteToken));
            //     }
            //     else {
            //         IUniswapV3Pool(pool).swap(
            //             address(this),
            //             zeroForOne,
            //             int256(start),
            //             zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
            //             abi.encode(baseToken));
            //     }
            // } else if (start < 0) {
            //     if (sellBaseToken) {
            //         IUniswapV3Pool(pool).swap(
            //             address(this),
            //             zeroForOne,
            //             -int256(start),
            //             zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
            //             abi.encode(baseToken));
            //     }
            //     else {
            //         IUniswapV3Pool(pool).swap(
            //             address(this),
            //             !zeroForOne,
            //             int256(start),
            //             !zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
            //             abi.encode(quoteToken));
            //     }            
            // }
        // } else {
        //     IPoolManager poolManager = launcher.v4PoolManager();
            
            // PoolKey memory poolKey = PoolKey({
            //     currency0: 0x0000000000000000000000000000000000000000,
            //     currency1: quoteToken,
            //     fee: launcher.v4Fee(),
            //     tickSpacing: launcher.v4TickSpacing(),
            //     hooks: launcher.v4Hooks()
            // });

        //     if (start > 0) {
        //         if (sellBaseToken) {
        //             poolManager.unlock(abi.encode(address(baseToken), uint256(start)));
        //         } else {
        //             poolManager.unlock(abi.encode(address(quoteToken), uint256(start)));
        //         }
        //     } else {
        //         if (sellBaseToken) {
        //             poolManager.unlock(abi.encode(address(quoteToken), uint256(-start)));
        //         } else {
        //             poolManager.unlock(abi.encode(address(baseToken), uint256(-start)));
        //         }
        //     }
        // }

        for (uint256 i = 0; i < stepCount; i++) {
            uint256 sqrtPriceX96 = launcher.getSqrtPriceX96(index);
            
            try launcher.launch(index, swapAmount, sellBaseToken, true) returns (int256 _profit) {
                if (_profit < int256(minProfit)) {
                    continue;
                }

                limtSqrtPriceX96 = sqrtPriceX96;
                profit = _profit;
                break;
            } catch {
                deltaAmount = deltaAmount + int256(step);

                // Step swap    
                _conductSwap(
                    address(this),
                    pool,
                    poolType,
                    baseToken,
                    quoteToken,
                    !sellBaseToken,
                    sellBaseToken ? (-int256(step)) : int256(step));
                // if (poolType == PoolType.UNISWAP_V3) {
                //     if (sellBaseToken) {
                //         IUniswapV3Pool(pool).swap(
                //             address(this),
                //             !zeroForOne,
                //             -int256(step),
                //             !zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
                //             abi.encode(quoteToken));
                //     }
                //     else {
                //         IUniswapV3Pool(pool).swap(
                //             address(this),
                //             zeroForOne,
                //             int256(step),
                //             zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1,
                //             abi.encode(baseToken));
                //     }
                // } else  {
                //     if (sellBaseToken) {
                //         poolManager.unlock(abi.encode(address(baseToken), step));
                //     } else {
                //         poolManager.unlock(abi.encode(address(quoteToken), step));
                //     }
                // }
            }
        }

        chainlinkPrice = launcher.getChainlinkPrice();
    }
}
*/