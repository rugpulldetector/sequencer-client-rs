// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "forge-std/Test.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../src/MSLauncherBase.sol";


contract MSLauncherTest is Test {
    using SafeERC20 for IERC20;

    function testMSSimulateBase() public {
        vm.label(USDC_BASE, "USDC");
        vm.label(WETH_BASE, "WETH");
        vm.label(msETH_BASE, "msETH");
        vm.label(msUSD_BASE, "msUSD");
        vm.label(msPool_BASE, "msPool");
        vm.label(WETH_msETH_PAIR_BASE, "WETH_msETH_PAIR");
        vm.label(msUSD_USDC_PAIR_BASE, "msUSD_USDC_PAIR");
        vm.label(msUSD_USDC_PAIR_BASE_2, "msUSD_USDC_PAIR_2");

        uint256 endNumber = 34652139;
        uint256 blockLookback = 1;
        uint256 startNumber = endNumber - blockLookback;
        uint256 gasLimit = 10000000;
        uint256 mUSDPrice;
        uint256 mUSDPrice2;

        MSLauncherBase launcher;

        for (uint256 i = 0; i < blockLookback; i++) {
            uint256 blockNumber = startNumber + i;
            int256 profit;
            uint256 chainlinkPrice;
            int256 deltaAmount;
            uint256 poolCount = 3;
            uint256 regressionCount = 5;
            uint256 swapAmount = 3 ether;
            uint256[] memory bidPrice = new uint256[](poolCount);
            uint256[] memory askPrice = new uint256[](poolCount);   
            MSLauncherBase simulator;
                
            for (uint256 poolIndex = 0; poolIndex < poolCount; poolIndex++) {
                console.log("----------- Pool Index -------------", poolIndex);

                vm.createSelectFork("base", blockNumber);
                launcher = new MSLauncherBase(base_controller);
                (address pool, PoolType poolType) = launcher.getPoolInfo(poolIndex);
                uint256 gas = gasleft();
                int256 startStep = -10 ether;
                int256 startStep2 = -10 ether;
                uint256 gapCount = 40;
                uint256 stepGap = poolType != PoolType.UNISWAP_V4 ? IERC20(WETH_BASE).balanceOf(pool) / gapCount : 100 ether;
                uint256 stepGap2 = stepGap;

                for (uint256 j = 0; j < regressionCount; j++) {
                    vm.createSelectFork("base", blockNumber);
                    launcher = MSLauncherBase(payable(0x558b6738759a5DBa97aab14CE602b8d20ba05087));
                    simulator = MSLauncherBase(payable(0x6F804aeE9d94DcE18B874defbc5DFC0334C14c99));
                    // launcher = new MSLauncherBase(base_controller);
                    // simulator = new MSLauncherBase(base_controller);
                    deal(WETH_BASE, address(simulator), 1000000 ether);
                    deal(USDC_BASE, address(simulator), 1 ether);
                    (bidPrice[poolIndex], chainlinkPrice, deltaAmount, profit) = simulator.getLimitPrice(
                        launcher, poolIndex, true, 
                        startStep, stepGap, gapCount, swapAmount, 0);

                    emit log_named_decimal_uint("Bid Price", launcher.convertSqrtPriceX96ToChainlink(bidPrice[poolIndex]), 8);
                    emit log_named_decimal_int("Delta Amount", deltaAmount, 18);
                    // emit log_named_decimal_uint("Profit", profit, 18);
                    emit log_named_decimal_int("Start Step", startStep, 18);
                    emit log_named_decimal_uint("Step Gap", stepGap, 18);
                    // emit log_named_decimal_uint("Gas", gas - gasleft(), 18);

                    startStep = deltaAmount - int256(stepGap);
                    stepGap = stepGap / 10;
                }

                for (uint256 j = 0; j < regressionCount; j++) {
                    vm.createSelectFork("base", blockNumber);
                    launcher = MSLauncherBase(payable(0x558b6738759a5DBa97aab14CE602b8d20ba05087));
                    simulator = MSLauncherBase(payable(0x6F804aeE9d94DcE18B874defbc5DFC0334C14c99));
                    deal(WETH_BASE, address(simulator), 1000000 ether);
                    deal(USDC_BASE, address(simulator), 1 ether);
                    (askPrice[poolIndex], chainlinkPrice, deltaAmount, profit) = simulator.getLimitPrice(
                        launcher, poolIndex, false, 
                        startStep2, stepGap2, gapCount, swapAmount, 0);

                    emit log_named_decimal_uint("Ask Price", launcher.convertSqrtPriceX96ToChainlink(askPrice[poolIndex]), 8);
                    emit log_named_decimal_int("Delta", deltaAmount, 18);
                    // emit log_named_decimal_uint("Profit", profit, 18);
                    emit log_named_decimal_int("Start Step", startStep2, 18);
                    emit log_named_decimal_uint("Step Gap", stepGap2, 18);
                    // emit log_named_decimal_uint("Gas", gas - gasleft(), 18);

                    startStep2 = deltaAmount - int256(stepGap2);
                    stepGap2 = stepGap2 / 10;
                }


                // vm.createSelectFork("base", blockNumber);
                // launcher = new MSLauncherBase(base_controller);
                // simulator = new MSSimulatorBase();
                // deal(WETH_BASE, address(simulator), 1000000 ether);
                // deal(USDC_BASE, address(simulator), 1 ether);
                // (askPrice[poolIndex], chainlinkPrice, deltaAmount, profit) = simulator.getLimitPrice(launcher, poolIndex, false, 0 ether, 30 ether, 20, 0);

                emit log_named_uint("Gas", gas - gasleft());
                emit log_named_decimal_uint("Final Bid Price", launcher.convertSqrtPriceX96ToChainlink(bidPrice[poolIndex]), 8);
                emit log_named_decimal_uint("Final Ask Price", launcher.convertSqrtPriceX96ToChainlink(askPrice[poolIndex]), 8);
                emit log_named_decimal_int("Final Delta", deltaAmount, 18);

                // bidPrice[poolIndex] = bidPrice[poolIndex] >> 32;
                // askPrice[poolIndex] = askPrice[poolIndex] >> 32;
            }


            vm.createSelectFork("base", blockNumber);
            launcher = new MSLauncherBase(base_controller);

            for (uint256 poolIndex = 0; poolIndex < poolCount; poolIndex++) {
                console.log("Pool Index", poolIndex);
                emit log_named_decimal_uint(" Bid Price", launcher.convertSqrtPriceX96ToChainlink(bidPrice[poolIndex]), 8);
                emit log_named_decimal_uint(" Ask Price", launcher.convertSqrtPriceX96ToChainlink(askPrice[poolIndex]), 8);
                
                uint256 price = launcher.getSqrtPriceX96(poolIndex);   
                emit log_named_decimal_uint("Pool Price", launcher.convertSqrtPriceX96ToChainlink(price), 8);

                if (bidPrice[poolIndex] < price) {
                    console.log("Sell opportunity");
                } else if (askPrice[poolIndex] > price) {
                    console.log("Buy opportunity");
                }
            }

            _launch(address(launcher), bidPrice, askPrice, gasLimit);
        }
    }

    function _launch(address launcher, uint256[] memory bidPrices, uint256[] memory askPrices, uint256 gasLimit) public {
        emit log_named_uint("Launch", block.number);

        uint96[] memory bidPrices96 = new uint96[](bidPrices.length);
        uint96[] memory askPrices96 = new uint96[](askPrices.length);
        for (uint256 i = 0; i < bidPrices.length; i++) {
            bidPrices96[i] = uint96(bidPrices[i]);
            askPrices96[i] = uint96(askPrices[i]);
        }

        bytes memory data;
        for (uint256 i = 0; i < bidPrices.length; i++) {
            data = bytes.concat(data, bytes12(uint96(bidPrices[i]))); // Cast to bytes12
            data = bytes.concat(data, bytes12(uint96(askPrices[i]))); // Cast to bytes12
        }

        // bytes memory data = abi.encodePacked(
        //     bidPrices96,
        //     askPrices96);
            // bytes12(uint96(bidPrices[0])),
            // bytes12(uint96(askPrices[0])),
            // bytes12(uint96(bidPrices[1])),
            // bytes12(uint96(askPrices[1])),
            // bytes12(uint96(bidPrices[2])),
            // bytes12(uint96(askPrices[2])),
            // bytes12(uint96(bidPrices[3])));
            // uint128(bidPrices[0] >> 32 + 1),
            // uint128(askPrices[0] >> 32),
            // uint128(bidPrices[1] >> 32+ 1),
            // uint128(askPrices[1] >> 32),
            // uint128(bidPrices[2] >> 32 + 1),
            // uint128(askPrices[2] >> 32),
            // uint128(bidPrices[3] >> 32 + 1),
            // uint128(askPrices[3]) >> 32);

        console.logBytes(data);

        address baseToken = IMSLauncher(launcher).getBaseToken();
        uint256 balance = IERC20(baseToken).balanceOf(base_controller);
        uint256 gas;

        gas = gasleft();
        launcher.call{gas: gasLimit}(data);
        uint256 profit = IERC20(baseToken).balanceOf(base_controller) - balance;
        emit log_named_uint("Gas", gas - gasleft());
        emit log_named_decimal_uint("Profit", profit, 18);
    }


    function testMSBase() public {
        vm.label(WETH_BASE, "WETH");
        vm.label(msETH_BASE, "msETH");
        vm.label(WETH_msETH_PAIR_BASE, "WETH_msETH_PAIR");

        vm.label(USDC_BASE, "USDC");
        vm.label(msUSD_BASE, "msUSD");
        vm.label(msUSD_USDC_PAIR_BASE, "msUSD_USDC_PAIR");

        uint256 blockLookback = 1;
        uint256 startNumber = 34652139;
        uint256 gasLimit = 10000000; 

        for (uint256 i = 0; i < blockLookback; i++) {
            uint256 blockNumber = startNumber + i;
            console.log("--------------------------------");
            console.log("Block Number", blockNumber);
            _simulate(blockNumber, gasLimit);
        }
    }


    function _launch(address launcher, uint256 gasLimit) public {
        address baseToken = IMSLauncher(launcher).getBaseToken();
        uint256 balance = IERC20(baseToken).balanceOf(base_controller);
        uint256 gas;

        gas = gasleft();
        launcher.call{gas: gasLimit}(bytes(""));
        uint256 profit = IERC20(baseToken).balanceOf(base_controller) - balance;
        emit log_named_uint("Launch Gas", gas - gasleft());
        emit log_named_decimal_uint("Launch Profit", profit, 18);
    }   

    function _simulate(uint256 blockNumber, uint256 gasLimit) public {
        uint256 gasUsed;
        int256 profit;
        uint256 poolCount = 3;
        AbstractMSLauncher launcher;
        AbstractMSLauncher simulator;

        for (uint256 direction = 0; direction < 2; direction++) {
            bool sellBaseToken = (direction == 0);
            for (uint256 poolIndex = 0; poolIndex < poolCount; poolIndex++) {
                for (uint256 i = 0; i < 10; i++) {

                    int256 delta = int256(i * 20 ether);
                    
                    (AbstractMSLauncher launcher, AbstractMSLauncher simulator) = createLauncherAndSimulator(0, blockNumber);
                    (uint256 limitPrice, uint256 swapAmount) = simulator.simulatePriceAndAmount(launcher, poolIndex, sellBaseToken, delta);

                    if (direction == 0) {
                        console.log("----------- Buy ------------");
                    } else {
                        console.log("----------- Sell ------------");
                    }

                    emit log_named_decimal_int("Delta", delta, 18);
                    emit log_named_decimal_uint("Chainlink Price", launcher.getChainlinkPrice(), 8);
                    emit log_named_decimal_uint("Pool Price", launcher.convertSqrtPriceX96ToChainlink(limitPrice), 8);
                    emit log_named_decimal_uint("Swap Amount", swapAmount, 18);

                    if (swapAmount > 0) {
                        (launcher, simulator) = createLauncherAndSimulator(0, blockNumber);
                        (limitPrice, profit, gasUsed) = simulator.simulateTrade(
                            launcher,
                            poolIndex,
                            sellBaseToken,
                            delta,
                            swapAmount);

                        emit log_named_decimal_int("Profit", profit, 18);
                        emit log_named_uint("Gas Used", gasUsed);


                        uint256[] memory limitPrices = new uint256[](1);
                        uint256[] memory swapAmounts = new uint256[](1);

                        limitPrices[0] = limitPrice;
                        swapAmounts[0] = swapAmount;

                        vm.createSelectFork("base", blockNumber);
                        (launcher, simulator) = createLauncherAndSimulator(0, blockNumber);
                        (profit, gasUsed) = simulator.simulateLaunch(
                            launcher,
                            poolIndex,
                            sellBaseToken,
                            delta + 0.001 ether,
                            limitPrices,
                            swapAmounts);

                        emit log_named_decimal_int("Launch Profit", profit, 18);
                        emit log_named_uint("Gas Used", gasUsed);
                    }
                }

            }

        }
    }

    function createLauncherAndSimulator(uint256 launcherType, uint256 blockNumber) internal returns (AbstractMSLauncher launcher, AbstractMSLauncher simulator) {
        vm.createSelectFork("base", blockNumber);
        
        launcher = MSLauncherBase(payable(0x558b6738759a5DBa97aab14CE602b8d20ba05087));
        simulator = MSLauncherBase(payable(0x6F804aeE9d94DcE18B874defbc5DFC0334C14c99));

        deal(WETH_BASE, address(simulator), 1000000 ether);
        deal(USDC_BASE, address(simulator), 1 ether);
    }    
}
