// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity 0.8.24;

import "forge-std/Test.sol";

import "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "../src/MSLauncherOP.sol";


contract MSLauncherTest is Test {
    using SafeERC20 for IERC20;

    function testMSSimulateOP() public {
        vm.label(WETH_OP, "WETH");
        vm.label(msETH_OP, "msETH");
        vm.label(WETH_msETH_PAIR_OP, "WETH_msETH_PAIR");

        vm.label(OP_OP, "OP");
        vm.label(msOP_OP, "msOP");
        vm.label(msOP_OP_PAIR_OP, "msOP_OP_PAIR");

        vm.label(USDC_OP, "USDC");
        vm.label(msUSD_OP, "msUSD");
        vm.label(msUSD_USDC_PAIR_OP, "msUSD_USDC_PAIR");

        vm.label(msPool_OP, "msPool");
        vm.label(ETH_FEED_OP, "ETH_FEED");
        vm.label(OP_FEED_OP, "OP_FEED");

        uint256 blockLookback = 1;
        uint256 blockNumber_WETH_OP = 139115807;
        uint256 blockNumber_WETH_USDC = 139249034;
        uint256 blockNumber_OP_USDC = 138601611;
        uint256 startNumber = 140121797;
        uint256 gasLimit = 10000000;
        AbstractMSLauncher launcher;
        AbstractMSLauncher simulator;   

        for (uint256 i = 0; i < blockLookback; i++) {
            uint256 blockNumber = startNumber + i;
            console.log("--------------------------------");
            console.log("Block Number", blockNumber);

            // uint256 startStep = 800 ether;
            // uint256 minStep = 56 ether;
            // uint256 startStep = 0.2 ether;
            // uint256 minStep = 0.05 ether;

            // for (uint256 j = 1; j < 5; j++) {
            //     uint256 step = j * 1e16;
            //     emit log_named_decimal_uint("Step", step, 18);

            // }

            // vm.createSelectFork("optimism", blockNumber);
            // launcher = address(new MSLauncherOP_OP_USDC(base_controller, startStep, minStep));
            // launcher = address(new MSLauncherOP_WETH_OP(base_controller, startStep, minStep));
            // _simulate(blockNumber, launcher);

            // launcher = address(new MSLauncherOP_OP_USDC(base_controller, startStep, minStep));
            // _simulateMSTrade(blockNumber, gasLimit);
            _simulate(blockNumber, gasLimit);

            // vm.createSelectFork("optimism", blockNumber);
            // launcher = new MSLauncherOP_WETH_USDC(base_controller, startStep, minStep);
            // simulator = new MSLauncherOP_WETH_USDC(base_controller, startStep, minStep);
            // _launch(blockNumber, launcher, simulator, gasLimit);
        }

        // console.log("----------- WETH_USDC -------------");
        // vm.createSelectFork("optimism", 138551554);
        // MSLauncherOP_WETH_USDC wethUSDCLauncher = new MSLauncherOP_WETH_USDC(base_controller);
        // _launch(address(wethUSDCLauncher), gasLimit);

        // console.log("----------- WETH_USDC_E -------------");
        // vm.createSelectFork("optimism", 138551554);
        // MSLauncherOP_WETH_USDC_E wethUSDCeLauncher = new MSLauncherOP_WETH_USDC_E(base_controller);
        // _launch(address(wethUSDCeLauncher), gasLimit);


        // console.log("----------- WETH_OP -------------");
        // vm.createSelectFork("optimism", 138601607);
        // MSLauncherOP_WETH_OP wethOPLauncher = new MSLauncherOP_WETH_OP(base_controller);
        // _launch(address(wethOPLauncher), gasLimit);

        // console.log("----------- OP_USDC -------------");
        // vm.createSelectFork("optimism", 138601611);
        // MSLauncherOP_OP_USDC opUSDCLauncher = new MSLauncherOP_OP_USDC(base_controller);
        // _launch(address(opUSDCLauncher), gasLimit);

        // console.log("----------- OP_USDC_E -------------");
        // vm.createSelectFork("optimism", 138601611);
        // MSLauncherOP_OP_USDC_E opUSDCeLauncher = new MSLauncherOP_OP_USDC_E(base_controller);
        // _launch(address(opUSDCeLauncher), step * 200, minStep * 200, gasLimit);
    }


    function _launch(address launcher, uint256 gasLimit) public {
        address baseToken = IMSLauncher(launcher).getBaseToken();
        uint256 balance = IERC20(baseToken).balanceOf(base_controller);
        uint256 gas;

        gas = gasleft();
        launcher.call{gas: gasLimit}(bytes(""));
        uint256 profit = IERC20(baseToken).balanceOf(base_controller) - balance;
        emit log_named_uint("Launch Gas", gas - gasleft());
        emit log_named_decimal_uint("Launch Profit", profit, 18);
    }   

    // function _simulateMSTrade(uint256 blockNumber, uint256 gasLimit) public {
        
    //     for (uint256 direction = 0; direction < 2; direction++) {
    //         for (uint256 i = 0; i < 10; i++) {
    //             (AbstractMSLauncher launcher, AbstractMSLauncher simulator) = createLauncherAndSimulator(0, blockNumber);
    //             uint256 swapAmount = simulator.simulateMSTrade(launcher, 0, direction == 0, i * 5 ether)
    //         }
    //     }
    // }

    function _simulate(uint256 blockNumber, uint256 gasLimit) public {
        uint256 gasUsed;
        int256 profit;
        uint256 poolCount = 1;
        AbstractMSLauncher launcher;
        AbstractMSLauncher simulator;

        // (launcher, simulator) = createLauncherAndSimulator(0, blockNumber);
        // (address pool, PoolType poolType) = launcher.getPoolInfo(poolIndex);
        // address baseToken = launcher.getBaseToken();
        // address quoteToken = launcher.getQuoteToken();
        // uint256[] memory baseBalance = new uint256[](poolCount);

        // for (uint256 i = 0; i < poolCount; i++) {
        //     baseBalance[i] = IERC20(baseToken).balanceOf(pool);
        // }

        for (uint256 direction = 0; direction < 1; direction++) {
            bool sellBaseToken = (direction == 0);
            for (uint256 poolIndex = 0; poolIndex < poolCount; poolIndex++) {
                for (uint256 i = 0; i < 10; i++) {

                    int256 delta = int256(i * 20 ether);
                    
                    (AbstractMSLauncher launcher, AbstractMSLauncher simulator) = createLauncherAndSimulator(0, blockNumber);
                    (uint256 limitPrice, uint256 swapAmount) = simulator.simulatePriceAndAmount(launcher, poolIndex, sellBaseToken, delta);

                    if (direction == 0) {
                        console.log("----------- Buy ------------");
                    } else {
                        console.log("----------- Sell ------------");
                    }

                    emit log_named_decimal_int("Delta", delta, 18);
                    emit log_named_decimal_uint("Chainlink Price", launcher.getChainlinkPrice(), 8);
                    emit log_named_decimal_uint("Pool Price", launcher.convertSqrtPriceX96ToChainlink(limitPrice), 8);
                    emit log_named_decimal_uint("Swap Amount", swapAmount, 18);

                    if (swapAmount > 0) {
                        (launcher, simulator) = createLauncherAndSimulator(0, blockNumber);
                        (limitPrice, profit, gasUsed) = simulator.simulateTrade(
                            launcher,
                            poolIndex,
                            sellBaseToken,
                            delta,
                            swapAmount);

                        emit log_named_decimal_int("Profit", profit, 18);
                        emit log_named_uint("Gas Used", gasUsed);


                        uint256[] memory limitPrices = new uint256[](1);
                        uint256[] memory swapAmounts = new uint256[](1);

                        limitPrices[0] = limitPrice;
                        swapAmounts[0] = swapAmount;

                        vm.createSelectFork("optimism", blockNumber);
                        launcher = new MSLauncherOP_WETH_USDC(base_controller);
                        simulator = new MSLauncherOP_WETH_USDC(base_controller);
                        deal(WETH_OP, address(simulator), 1000000 ether);
                        deal(USDC_OP, address(simulator), 1 ether);
                        deal(OP_OP, address(simulator), 1000000 ether);
                        (profit, gasUsed) = simulator.simulateLaunch(
                            launcher,
                            poolIndex,
                            sellBaseToken,
                            delta + 0.001 ether,
                            limitPrices,
                            swapAmounts);

                        emit log_named_decimal_int("Launch Profit", profit, 18);
                        emit log_named_uint("Gas Used", gasUsed);
                    }
                }

            }

        }
    }

    function createLauncherAndSimulator(uint256 launcherType, uint256 blockNumber) internal returns (AbstractMSLauncher launcher, AbstractMSLauncher simulator) {
        vm.createSelectFork("optimism", blockNumber);
        if (launcherType == 0) {
            launcher = MSLauncherOP_WETH_USDC(0xca30f788ca4198056d7A77F89b95FBAF142113D3);
            simulator = MSLauncherOP_WETH_USDC(0x93D7f2AD0FB630eE77b3429253845843576B7976);
            // launcher = new MSLauncherOP_WETH_USDC(base_controller);
            // simulator = new MSLauncherOP_WETH_USDC(base_controller);
        } else if (launcherType == 1) {
            launcher = new MSLauncherOP_WETH_USDC_E(base_controller);
            simulator = new MSLauncherOP_WETH_USDC_E(base_controller);
        } else if (launcherType == 2) {
            launcher = new MSLauncherOP_WETH_OP(base_controller);
            simulator = new MSLauncherOP_WETH_OP(base_controller);
        }

        deal(WETH_OP, address(simulator), 1000000 ether);
        deal(USDC_OP, address(simulator), 1 ether);
        deal(OP_OP, address(simulator), 1000000 ether);
    }


    // function getSimulationPrice(address launcher, uint256 blockNumber) public returns (uint256 price) {
    //     vm.createSelectFork("optimism", blockNumber);
    //     MSSimulatorOP simulator = new MSSimulatorOP();
    //     (int256 profit, bool sellBaseToken) = simulator.getLimitPrice(MSLauncherOP(launcher), 0, true, 0, 1000000000000000000, 1000000000000000000);
    //     return price;
    // }

}
